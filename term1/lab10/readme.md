# Теория по индексам в SQL Server

## Что такое индексы?

**Индекс** - это объект базы данных, который ускоряет поиск данных в таблице за счет организации данных в виде сбалансированного дерева (B-дерева). Представьте себе индекс в книге - вместо того чтобы читать всю книгу, вы сразу находите нужную страницу.

## Типы индексов

### 1. Кластеризованный индекс (Clustered Index)

-   **Определение**: Определяет физический порядок данных в таблице
-   **Особенности**:
    -   В таблице может быть только ОДИН кластеризованный индекс
    -   Данные в таблице физически упорядочены по ключу индекса
    -   Создается автоматически при создании PRIMARY KEY
-   **Синтаксис**:

```sql
CREATE CLUSTERED INDEX IX_Имя ON Таблица(Столбец);
```

### 2. Некластеризованный индекс (Nonclustered Index)

-   **Определение**: Отдельная структура, содержащая ключи и указатели на данные
-   **Особенности**:
    -   В таблице может быть несколько некластеризованных индексов
    -   Не влияет на физический порядок данных
    -   Быстрее для операций чтения, но медленнее для операций записи
-   **Синтаксис**:

```sql
CREATE INDEX IX_Имя ON Таблица(Столбец);
```

## Виды индексов по структуре

### 1. Простой индекс

```sql
CREATE INDEX IX_Товары_Цена ON Товары(Цена);
```

### 2. Составной индекс (по нескольким столбцам)

```sql
CREATE INDEX IX_Заказы_Составной ON Заказы(Заказчик, Дата_поставки);
```

### 3. Уникальный индекс

```sql
CREATE UNIQUE INDEX IX_Уникальный ON Таблица(Столбец);
```

### 4. Индекс покрытия (Covering Index)

-   **Определение**: Содержит все столбцы, необходимые для запроса
-   **Преимущество**: Исключает обращение к самой таблице

```sql
CREATE INDEX IX_Покрытия ON Заказы(Заказчик)
INCLUDE (Наименование_товара, Цена_продажи);
```

### 5. Фильтруемый индекс (Filtered Index)

-   **Определение**: Индекс по подмножеству строк таблицы

```sql
CREATE INDEX IX_Фильтрованный ON Товары(Цена)
WHERE Цена > 1000;
```

## Параметры индексов

### FILLFACTOR

-   Определяет процент заполнения страниц индекса
-   Значение от 1 до 100

```sql
CREATE INDEX IX_Пример ON Таблица(Столбец)
WITH (FILLFACTOR = 80);
```

### PAD_INDEX

-   Распространяет FILLFACTOR на промежуточные страницы индекса

```sql
CREATE INDEX IX_Пример ON Таблица(Столбец)
WITH (FILLFACTOR = 80, PAD_INDEX = ON);
```

## Обслуживание индексов

### 1. Реорганизация индекса (REORGANIZE)

-   Дефрагментирует индекс на нижнем уровне
-   Выполняется быстро, минимально блокирует таблицу

```sql
ALTER INDEX IX_Имя ON Таблица REORGANIZE;
```

### 2. Перестройка индекса (REBUILD)

-   Полностью перестраивает индекс
-   Устраняет фрагментацию полностью

```sql
ALTER INDEX IX_Имя ON Таблица REBUILD;
```

### 3. Отключение индекса

```sql
ALTER INDEX IX_Имя ON Таблица DISABLE;
```

### 4. Удаление индекса

```sql
DROP INDEX IX_Имя ON Таблица;
```

## Мониторинг индексов

### Проверка фрагментации

```sql
SELECT
    name AS [Индекс],
    avg_fragmentation_in_percent AS [Фрагментация (%)]
FROM sys.dm_db_index_physical_stats(
    DB_ID(N'X_MyBASE'),
    OBJECT_ID(N'Заказы'),
    NULL, NULL, NULL
) ss
JOIN sys.indexes ii ON ss.object_id = ii.object_id
    AND ss.index_id = ii.index_id
WHERE name IS NOT NULL;
```

### Просмотр существующих индексов

```sql
EXEC sp_helpindex 'Заказы';
```

## Когда создавать индексы?

### Создавать индексы для:

-   Столбцов в условиях WHERE
-   Столбцов в JOIN условиях
-   Столбцов в ORDER BY
-   Столбцов с уникальными значениями

### Не создавать индексы для:

-   Таблиц с частыми операциями INSERT/UPDATE/DELETE
-   Столбцов с малым количеством уникальных значений
-   Очень маленьких таблиц

## Практические рекомендации

### Перед созданием индекса:

1. Анализируйте частые запросы
2. Используйте Display Estimated Execution Plan
3. Проверяйте селективность столбцов

### После создания индекса:

1. Проверяйте производительность запросов
2. Мониторьте фрагментацию
3. Планируйте регулярное обслуживание

Эта теория покрывает все аспекты, необходимые для выполнения лабораторной работы с вашими таблицами X_MyBASE!
